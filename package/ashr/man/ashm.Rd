% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/ashutility.R
\name{ashm}
\alias{ashm}
\title{Multi-model Adaptive Shrinkage function}
\usage{
ashm(betahat, sebetahat, method = c("shrink", "fdr"),
  mixcompdist = c("uniform", "halfuniform", "normal"), lambda1 = 1,
  lambda2 = 0, df = NULL, nullweight = 10, nonzeromode = FALSE,
  alpha = 2, ncores = FALSE)
}
\arguments{
\item{betahat}{a p vector of estimates}

\item{sebetahat}{a p vector of corresponding standard errors}

\item{method}{specifies how ash is to be run. Can be "shrinkage" (if main aim is shrinkage) or "fdr" (if main aim is to assess fdr or fsr)
This is simply a convenient way to specify certain combinations of parameters: "shrinkage" sets pointmass=FALSE and prior="uniform";
"fdr" sets pointmass=TRUE and prior="nullbiased".}

\item{mixcompdist}{distribution of components in mixture ( "uniform","halfuniform" or "normal"), the default value would be "uniform"}

\item{lambda1}{multiplicative "inflation factor" for standard errors (like Genomic Control)}

\item{lambda2}{additive "inflation factor" for standard errors (like Genomic Control)}

\item{df}{appropriate degrees of freedom for (t) distribution of betahat/sebetahat, default is NULL(Gaussian)}

\item{nullweight}{scalar, the weight put on the prior under "nullbiased" specification, see \code{prior}}

\item{nonzeromode}{logical, indicating whether to use a non-zero unimodal mixture(default is "FALSE")}

\item{alpha}{Could be a vector of grid values in interval [0,1], that this wrapper would select based on likelihood principle. Could also be a positive integer greater or equal to 2, then alpha number of grid values would be generated from [0,1], equally spaced. The default value is 2 that we compare the EE and ES model.}

\item{ncores}{Whether to use parallel computing, defaults to FALSE, user could specify number of cores they would like to use. Further, if user does not specify and length(betahat)>50000, then the function would perform parallel computation using number of CPU cores on the current host.}
}
\value{
ashm returns a list of objects
\item{beta.ash}{the best fitted ash object}
\item{loglikvector}{the vector of loglikelihood of various models}
\item{allash}{the fitted ash of various models}
}
\description{
This is a wrapper function that takes a grid value of \eqn{alpha} and then consider the model \eqn{betahat_j / s_j^{alpha} ~ g()},and eqn{beta_j / s_j^{alpha} ~ N(0,(sebetahat^(1-alpha))^2) or student t distribution}. When \eqn{alpha=0} we have the EE model, when \eqn{alpha=1}, we have the ES model. \eqn{alpha} should be in between 0 and 1, inclusively. This wrapper function would select the best \eqn{alpha} and reports the ash item based on that \eqn{alpha}.
}
\details{
All other inputs are exactly the same as the main function ash, and would pass to the main function to evaluate the likelihood.
}
\examples{
beta = c(rep(0,100),rnorm(100))
sebetahat = abs(rnorm(200,0,1))
betahat = rnorm(200,beta,sebetahat)
beta.ashm = ashm(betahat, sebetahat,alpha=6)
#beta.ashm4 = ashm(betahat, sebetahat,alpha=6,ncores=4)
print(beta.ashm[[1]])  #best ash object
print(beta.ashm[[2]])  #corresponding model type
print(beta.ashm[[3]])  #log-likelihood for all models
}
\seealso{
\code{\link{ash}} the main function that this wrapper function is calling
}

